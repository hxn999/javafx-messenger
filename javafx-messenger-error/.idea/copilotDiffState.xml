<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/main/java/com/Application/App.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/main/java/com/Application/App.java" />
              <option name="originalContent" value="package com.Application;&#10;&#10;import com.api.Receiver;&#10;import com.api.Sender;&#10;import com.client.chat.ChatController;&#10;import com.client.util.Page;&#10;import com.client.util.Pages;&#10;import com.db.SignedUser;&#10;import javafx.application.Application;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.image.Image;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;import java.net.Socket;&#10;&#10;public class App extends Application {&#10;&#10;    // making the stage global for accessing&#10;    public static Stage globalStage;&#10;    public static ChatController chatController;&#10;    @Override&#10;    public void start(Stage stage) throws IOException {&#10;        globalStage = stage;&#10;        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(&quot;/views/login.fxml&quot;));&#10;        Parent root = fxmlLoader.load();&#10;        Scene scene = new Scene(root, 1000, 600);&#10;        stage.setResizable(false);&#10;        stage.getIcons().add(new Image(getClass().getResourceAsStream(&quot;/icons/icons8-chat-message-100.png&quot;)));&#10;        stage.setTitle(&quot;Messenger&quot;);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;&#10;        // If user is logged in, go to chat page and set chatController&#10;        if (SignedUser.isLoggedIn()) {&#10;            try {&#10;                FXMLLoader chatLoader = new FXMLLoader(getClass().getResource(&quot;/views/chat.fxml&quot;));&#10;                Parent chatRoot = chatLoader.load();&#10;                chatController = chatLoader.getController();&#10;                Scene chatScene = new Scene(chatRoot, 1000, 600);&#10;                globalStage.setScene(chatScene);&#10;                globalStage.show();&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;&#10;        // Networking should be initialized after UI is ready&#10;        initNetworking();&#10;    }&#10;&#10;    private void initNetworking() {&#10;        try {&#10;            Socket socket = new Socket(&quot;127.0.0.1&quot;, 5000);&#10;            Sender sender = new Sender(&quot;Sender-Thread&quot;, socket);&#10;            // Pass chatController if available, else null&#10;            Receiver msgReceiver = new Receiver(&quot;Receiver-Thread&quot;, socket, chatController);&#10;            Sender.sender = sender;&#10;            sender.start();&#10;            msgReceiver.start();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SignedUser.loadFromFile();&#10;        System.out.println(SignedUser.chatList.size());&#10;        launch(args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.Application;&#10;&#10;import com.api.Receiver;&#10;import com.api.Sender;&#10;import com.client.chat.ChatController;&#10;import com.client.util.Page;&#10;import com.client.util.Pages;&#10;import com.db.SignedUser;&#10;import javafx.application.Application;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.image.Image;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;import java.net.Socket;&#10;&#10;public class App extends Application {&#10;&#10;    // making the stage global for accessing&#10;    public static Stage globalStage;&#10;    public static ChatController chatController;&#10;    @Override&#10;    public void start(Stage stage) throws IOException {&#10;        globalStage = stage;&#10;        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(&quot;/views/login.fxml&quot;));&#10;        Parent root = fxmlLoader.load();&#10;        Scene scene = new Scene(root, 1000, 600);&#10;        stage.setResizable(false);&#10;        stage.getIcons().add(new Image(getClass().getResourceAsStream(&quot;/icons/icons8-chat-message-100.png&quot;)));&#10;        stage.setTitle(&quot;Messenger&quot;);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;&#10;        // If user is logged in, go to chat page and set chatController&#10;        if (SignedUser.isLoggedIn()) {&#10;            try {&#10;                FXMLLoader chatLoader = new FXMLLoader(getClass().getResource(&quot;/views/chat.fxml&quot;));&#10;                Parent chatRoot = chatLoader.load();&#10;                chatController = chatLoader.getController();&#10;                Scene chatScene = new Scene(chatRoot, 1000, 600);&#10;                globalStage.setScene(chatScene);&#10;                globalStage.show();&#10;                // Networking should be initialized after chatController is set&#10;                initNetworking(chatController);&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;        } else {&#10;            // Networking should be initialized after UI is ready (login page)&#10;            initNetworking(null);&#10;        }&#10;    }&#10;&#10;    private void initNetworking(ChatController chatController) {&#10;        try {&#10;            Socket socket = new Socket(&quot;127.0.0.1&quot;, 5000);&#10;            Sender sender = new Sender(&quot;Sender-Thread&quot;, socket);&#10;            Receiver msgReceiver = new Receiver(&quot;Receiver-Thread&quot;, socket, chatController);&#10;            Sender.sender = sender;&#10;            sender.start();&#10;            msgReceiver.start();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SignedUser.loadFromFile();&#10;        System.out.println(SignedUser.chatList.size());&#10;        launch(args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/main/java/com/api/Receiver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/main/java/com/api/Receiver.java" />
              <option name="originalContent" value="package com.api;&#10;&#10;//import com.db.ClientChat;&#10;&#10;import com.client.chat.ChatController;&#10;import com.client.util.ReceiverPhone;&#10;import com.db.Chat;&#10;import com.db.Message;&#10;import com.db.SignedUser;&#10;import com.server.Response;&#10;import javafx.application.Platform;&#10;&#10;import java.io.*;&#10;import java.net.Socket;&#10;&#10;public class Receiver extends Thread {&#10;&#10;&#10;    public static ObjectInputStream receive;&#10;    private Socket socket;&#10;    private ChatController chatController;&#10;&#10;    public Receiver(String name, Socket socket, ChatController chatController) {&#10;        super(name);&#10;        this.socket = socket;&#10;        this.chatController = chatController;&#10;&#10;        try {&#10;            receive = new ObjectInputStream(this.socket.getInputStream());&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;&#10;    private synchronized void receive() {&#10;&#10;        while (true) {&#10;            Object obj = null;&#10;            System.out.println(&quot;waiting to receive&quot;);&#10;            try {&#10;                obj = receive.readObject();&#10;            System.out.println(&quot; receive ses&quot;);&#10;            } catch (IOException e) {&#10;                throw new RuntimeException(e);&#10;            } catch (ClassNotFoundException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;&#10;            if (obj instanceof Response response) {&#10;                // Check if it's a response to a previous request&#10;                if (response.getRequestId() != null) {&#10;                    System.out.println(&quot;response: &quot; + response.getRequestId());&#10;                    ResponseManager.complete(response.getRequestId(), response);&#10;                } else {&#10;                    // It’s a real-time event (e.g., chat message)&#10;&#10;                    handleRealtimeMessage(obj);&#10;                }&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;&#10;    private synchronized void handleRealtimeMessage(Object o) {&#10;&#10;        Platform.runLater(()-&gt;{&#10;&#10;            if(o instanceof Message){&#10;&#10;                Message msg = (Message)o;&#10;&#10;                ChatController.allChats.get(msg.getChatId()).addMessage(msg);&#10;&#10;                // re render chat list&#10;                chatController.populateChatList();&#10;&#10;                if(ChatController.currentChatId==msg.getChatId()){&#10;                    // render chat bubble&#10;                    chatController.addMessageBubble(msg.getMessage(),false);&#10;                }&#10;&#10;&#10;            }&#10;&#10;&#10;            // initializing new chat&#10;            if(o instanceof Chat){&#10;                Chat chat = (Chat) o;&#10;                ChatController.allChats.put(chat.getChatId(), chat);&#10;                ChatController.receiverMap.put(ReceiverPhone.get(chat),chat.getChatId());&#10;                SignedUser.chatList.add(chat.getChatId());&#10;&#10;                // re render chatlist&#10;                chatController.populateChatList();&#10;                if(ChatController.currentChatId==chat.getChatId()){&#10;                    // render chat bubble&#10;                    chatController.addMessageBubble(chat.getMessages().get(0).getMessage(),false);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;&#10;    @Override&#10;    public void run() {&#10;&#10;        receive();&#10;&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.api;&#10;&#10;//import com.db.ClientChat;&#10;&#10;import com.client.chat.ChatController;&#10;import com.client.util.ReceiverPhone;&#10;import com.db.Chat;&#10;import com.db.Message;&#10;import com.db.SignedUser;&#10;import com.server.Response;&#10;import javafx.application.Platform;&#10;&#10;import java.io.*;&#10;import java.net.Socket;&#10;&#10;public class Receiver extends Thread {&#10;&#10;&#10;    public static ObjectInputStream receive;&#10;    private Socket socket;&#10;    private ChatController chatController;&#10;&#10;    public Receiver(String name, Socket socket, ChatController chatController) {&#10;        super(name);&#10;        this.socket = socket;&#10;        this.chatController = chatController;&#10;&#10;        try {&#10;            receive = new ObjectInputStream(this.socket.getInputStream());&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;&#10;    private synchronized void receive() {&#10;&#10;        while (true) {&#10;            Object obj = null;&#10;            System.out.println(&quot;waiting to receive&quot;);&#10;            try {&#10;                obj = receive.readObject();&#10;            System.out.println(&quot; receive ses&quot;);&#10;            } catch (IOException e) {&#10;                throw new RuntimeException(e);&#10;            } catch (ClassNotFoundException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;&#10;            if (obj instanceof Response response) {&#10;                // Check if it's a response to a previous request&#10;                if (response.getRequestId() != null) {&#10;                    System.out.println(&quot;response: &quot; + response.getRequestId());&#10;                    ResponseManager.complete(response.getRequestId(), response);&#10;                } else {&#10;                    // It’s a real-time event (e.g., chat message)&#10;&#10;                    handleRealtimeMessage(obj);&#10;                }&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;&#10;    private synchronized void handleRealtimeMessage(Object o) {&#10;        Platform.runLater(() -&gt; {&#10;            if (chatController == null) {&#10;                System.err.println(&quot;ChatController is not initialized for real-time message handling.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (o instanceof Message) {&#10;                Message msg = (Message) o;&#10;                ChatController.allChats.get(msg.getChatId()).addMessage(msg);&#10;                chatController.populateChatList();&#10;                if (ChatController.currentChatId == msg.getChatId()) {&#10;                    chatController.addMessageBubble(msg.getMessage(), false);&#10;                }&#10;            }&#10;&#10;            if (o instanceof Chat) {&#10;                Chat chat = (Chat) o;&#10;                ChatController.allChats.put(chat.getChatId(), chat);&#10;                ChatController.receiverMap.put(ReceiverPhone.get(chat), chat.getChatId());&#10;                SignedUser.chatList.add(chat.getChatId());&#10;                chatController.populateChatList();&#10;                if (ChatController.currentChatId == chat.getChatId()) {&#10;                    chatController.addMessageBubble(chat.getMessages().get(0).getMessage(), false);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;&#10;    @Override&#10;    public void run() {&#10;&#10;        receive();&#10;&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/main/java/com/api/Sender.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/main/java/com/api/Sender.java" />
              <option name="originalContent" value="package com.api;&#10;&#10;import java.io.*;&#10;import java.net.Socket;&#10;&#10;import com.db.Message;&#10;import com.db.SignedUser;&#10;import com.db.User;&#10;import com.server.Response;&#10;&#10;public class Sender extends Thread {&#10;&#10;    private Socket socket;&#10;    private String type;&#10;&#10;    private ObjectOutputStream send;&#10;    public static Sender sender;&#10;    private Response request;&#10;&#10;    public Sender(String name, Socket socket) {&#10;        super(name);&#10;        this.socket = socket;&#10;        try {&#10;&#10;            this.send = new ObjectOutputStream(socket.getOutputStream());&#10;            System.out.println(send);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;&#10;        this.sender = this;&#10;    }&#10;&#10;    private void request() {&#10;        synchronized (this) {&#10;            while (true) {&#10;                try {&#10;                    System.out.println(&quot;waiting&quot;);&#10;                    wait();&#10;&#10;                    System.out.println(&quot;sending request&quot;);&#10;&#10;&#10;                    // Create a Response object with the request as the body&#10;&#10;                    send.writeObject(request);&#10;                    send.flush();&#10;&#10;                    System.out.println(&quot;sending request finished&quot;);&#10;                } catch (InterruptedException e) {&#10;                    e.printStackTrace();&#10;                } catch (IOException e) {&#10;                    e.printStackTrace();&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public synchronized void sendMessage(Message msg, String requestId) {&#10;        request = new Response(SignedUser.phone,msg,Path.MSG,requestId);&#10;&#10;        notify();&#10;    }&#10;&#10;    public synchronized void login(String phone, String password, String requestId) {&#10;        System.out.println(requestId);&#10;        Data body = new Data();&#10;        body.phone = phone;&#10;        body.password = password;&#10;        request = new Response(SignedUser.phone,body,Path.LOGIN,requestId);&#10;        notify();&#10;    }&#10;&#10;    public synchronized void searchUser(String name, String requestId) {&#10;        Data body = new Data();&#10;        body.recieverName = name;&#10;        request = new Response(SignedUser.phone,body,Path.SEARCH,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void block(String phone, String requestId) {&#10;        Data body = new Data();&#10;        body.receiverPhone = phone;&#10;        request = new Response(SignedUser.phone,body,Path.BLOCK,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void unblock(String phone, String requestId) {&#10;        Data body = new Data();&#10;        body.receiverPhone = phone;&#10;        request = new Response(SignedUser.phone,body,Path.UNBLOCK,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;&#10;&#10;&#10;    public synchronized void createAccount(String name, String phone, String password, String url, String requestId) {&#10;        User newUser = new User(name,url,phone,password);&#10;&#10;        request = new Response(newUser.getPhone(),newUser,Path.CREATE_ACCOUNT,requestId);&#10;        notify();&#10;&#10;    }&#10;&#10;&#10;    public synchronized void fetchChat(int chatId, String requestId) {&#10;        Data body = new Data();&#10;        body.chatId = chatId;&#10;        request = new Response(SignedUser.phone,body,Path.CHAT,requestId);&#10;        notify();&#10;    }&#10;&#10;    public synchronized void searchSingle(String phone, String requestId) {&#10;&#10;        Data body = new Data();&#10;        body.receiverPhone = phone;&#10;        request = new Response(SignedUser.phone,body,Path.SINGLE_SEARCH,requestId);&#10;        notify();&#10;    }&#10;&#10;&#10;&#10;    @Override&#10;    public void run() {&#10;        request();&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.api;&#10;&#10;import java.io.*;&#10;import java.net.Socket;&#10;&#10;import com.db.Message;&#10;import com.db.SignedUser;&#10;import com.db.User;&#10;import com.server.Response;&#10;&#10;public class Sender extends Thread {&#10;&#10;    private Socket socket;&#10;    private String type;&#10;&#10;    private ObjectOutputStream send;&#10;    public static Sender sender;&#10;    private Response request;&#10;&#10;    public Sender(String name, Socket socket) {&#10;        super(name);&#10;        this.socket = socket;&#10;        try {&#10;&#10;            this.send = new ObjectOutputStream(socket.getOutputStream());&#10;            System.out.println(send);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        Sender.sender = this;&#10;    }&#10;&#10;    private void request() {&#10;        synchronized (this) {&#10;            while (true) {&#10;                try {&#10;                    System.out.println(&quot;waiting&quot;);&#10;                    wait();&#10;&#10;                    System.out.println(&quot;sending request&quot;);&#10;&#10;&#10;                    // Create a Response object with the request as the body&#10;&#10;                    send.writeObject(request);&#10;                    send.flush();&#10;&#10;                    System.out.println(&quot;sending request finished&quot;);&#10;                } catch (InterruptedException e) {&#10;                    e.printStackTrace();&#10;                } catch (IOException e) {&#10;                    e.printStackTrace();&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public synchronized void sendMessage(Message msg, String requestId) {&#10;        request = new Response(SignedUser.phone,msg,Path.MSG,requestId);&#10;&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void login(String phone, String password, String requestId) {&#10;        System.out.println(requestId);&#10;        Data body = new Data();&#10;        body.phone = phone;&#10;        body.password = password;&#10;        request = new Response(SignedUser.phone,body,Path.LOGIN,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void searchUser(String name, String requestId) {&#10;        Data body = new Data();&#10;        body.recieverName = name;&#10;        request = new Response(SignedUser.phone,body,Path.SEARCH,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void block(String phone, String requestId) {&#10;        Data body = new Data();&#10;        body.receiverPhone = phone;&#10;        request = new Response(SignedUser.phone,body,Path.BLOCK,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void unblock(String phone, String requestId) {&#10;        Data body = new Data();&#10;        body.receiverPhone = phone;&#10;        request = new Response(SignedUser.phone,body,Path.UNBLOCK,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;&#10;&#10;&#10;    public synchronized void createAccount(String name, String phone, String password, String url, String requestId) {&#10;        User newUser = new User(name,url,phone,password);&#10;&#10;        request = new Response(newUser.getPhone(),newUser,Path.CREATE_ACCOUNT,requestId);&#10;        notifyAll();&#10;&#10;    }&#10;&#10;&#10;    public synchronized void fetchChat(int chatId, String requestId) {&#10;        Data body = new Data();&#10;        body.chatId = chatId;&#10;        request = new Response(SignedUser.phone,body,Path.CHAT,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized void searchSingle(String phone, String requestId) {&#10;&#10;        Data body = new Data();&#10;        body.receiverPhone = phone;&#10;        request = new Response(SignedUser.phone,body,Path.SINGLE_SEARCH,requestId);&#10;        notifyAll();&#10;    }&#10;&#10;&#10;&#10;    @Override&#10;    public void run() {&#10;        request();&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client/src/main/java/com/client/chat/ChatController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/main/java/com/client/chat/ChatController.java" />
              <option name="originalContent" value="package com.client.chat;&#10;&#10;//import com.fasterxml.jackson.core.json.DupDetector;&#10;&#10;&#10;import com.api.ResponseManager;&#10;import com.api.Sender;&#10;import com.client.util.*;&#10;//import com.db.ClientChat;&#10;import com.db.*;&#10;import com.server.Response;&#10;import javafx.application.Platform;&#10;import javafx.beans.binding.Bindings;&#10;import javafx.event.ActionEvent;            // ← JavaFX ActionEvent&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Pos;&#10;import javafx.geometry.Side;&#10;import javafx.scene.Node;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.*;&#10;import javafx.scene.image.Image;&#10;import javafx.scene.image.ImageView;&#10;import javafx.scene.input.MouseEvent;&#10;import javafx.scene.layout.HBox;&#10;import javafx.scene.layout.VBox;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.text.FontWeight;&#10;import javafx.scene.text.Text;&#10;import javafx.scene.text.TextFlow;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;import java.time.LocalTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;public class ChatController {&#10;    @FXML&#10;    public Button settingsButton;&#10;    @FXML&#10;    private ImageView searchIcon;&#10;    @FXML&#10;    private TextField searchField;&#10;    @FXML&#10;    private ImageView clearSearch;&#10;    @FXML&#10;    private VBox contactsBox;&#10;    @FXML&#10;    private VBox chatList;&#10;    private int chatId;&#10;&#10;    @FXML&#10;&#10;    private Button dotsButton;&#10;&#10;    @FXML&#10;&#10;    private Button blockUserButton;  // we'll still call this if you want to reuse its handler&#10;&#10;    @FXML&#10;    private ImageView userImage;&#10;    @FXML&#10;    private Label userName;&#10;&#10;&#10;    // our ContextMenu and MenuItem&#10;    @FXML&#10;    private ContextMenu dotsMenu;&#10;    @FXML&#10;    private MenuItem blockUserItem;&#10;    @FXML&#10;    private String currentChatPhone;&#10;&#10;    @FXML&#10;    private ImageView sendIcon;&#10;    @FXML&#10;    private TextField messageField;&#10;    @FXML&#10;    private ScrollPane messageScrollPane;&#10;    @FXML&#10;    private VBox messageContainer;&#10;    // its content VBox&#10;    @FXML&#10;    private ImageView headerAvatar;            // the avatar in the header bar&#10;    @FXML&#10;    private Label headerNameLabel;           // the username in the header bar// bottom “write here…” TextField&#10;    @FXML&#10;    private Button sendButton;&#10;    @FXML&#10;    private Label receiverName;&#10;    @FXML&#10;    private ImageView receiverImage;&#10;&#10;    // maps receiver phone to chat id&#10;    public static Map&lt;String,Integer&gt; receiverMap;&#10;    //&#10;    boolean hadChat = false;&#10;    public static Integer currentChatId=null;&#10;    private String currentReceiverPhone;&#10;    public static List&lt;User&gt; allChatUser;&#10;//    private List&lt;ClientChat&gt; chats;&#10;&#10;&#10;    public static Map&lt;Integer, Chat&gt; allChats = new HashMap&lt;&gt;();&#10;&#10;&#10;    public static void addOrUpdateUser(User user) {&#10;        for (int i = 0; i &lt; allChatUser.size(); i++) {&#10;            if (allChatUser.get(i).getPhone().equals(user.getPhone())) {&#10;                allChatUser.set(i, user); // update&#10;                return;&#10;            }&#10;        }&#10;        allChatUser.add(user); // add if not found&#10;    }&#10;&#10;    public static Optional&lt;User&gt; findUser(String phone) {&#10;        return allChatUser.stream()&#10;                .filter(u -&gt; u.getPhone().equals(phone))&#10;                .findFirst();&#10;    }&#10;&#10;    /**&#10;     * This must be annotated @FXML so FXMLLoader sees it.&#10;     */&#10;    @FXML&#10;    private void initialize() {&#10;        allChatUser= new ArrayList&lt;&gt;();&#10;        // optional setup after FXML is loaded&#10;        settingsButton.setOnAction(this::onSettingsClicked);&#10;&#10;&#10;        clearSearch.visibleProperty().bind(&#10;                Bindings.createBooleanBinding(&#10;                        () -&gt; !searchField.getText().trim().isEmpty(),&#10;                        searchField.textProperty()&#10;                )&#10;        );&#10;&#10;        // also remove it from layout when invisible&#10;        clearSearch.managedProperty().bind(clearSearch.visibleProperty());&#10;&#10;        // so that clicks through the transparent area don't block typing&#10;&#10;        clearSearch.visibleProperty().bind(searchField.textProperty().isNotEmpty());&#10;        clearSearch.managedProperty().bind(clearSearch.visibleProperty());&#10;        clearSearch.mouseTransparentProperty().bind(clearSearch.visibleProperty().not());&#10;        clearSearch.setPickOnBounds(false);&#10;//        searchIcon.setPickOnBounds(false);&#10;&#10;        // build the popup menu&#10;        dotsMenu = new ContextMenu();&#10;        blockUserItem = new MenuItem(&quot;Block User&quot;);&#10;        dotsMenu.getItems().add(blockUserItem);&#10;&#10;        // what happens when &quot;Block User&quot; is clicked&#10;        blockUserItem.setOnAction(e -&gt; {&#10;            onBlockUserClicked();&#10;        });&#10;&#10;        userName.setText(SignedUser.name);&#10;//        Base64ImageHelper.getImageViewFromBase64(userImage,SignedUser.url,50,50);&#10;//        System.out.println(SignedUser.url);&#10;        userImage.setImage(Base64ImageHelper.getImageViewFromBase64(SignedUser.url));&#10;        // load all chats from file&#10;&#10;//        loadAllChat();&#10;        receiverMap = new HashMap&lt;&gt;();&#10;        // loading all chats&#10;        List&lt;CompletableFuture&lt;Response&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;&#10;        for (int chatId : SignedUser.chatList) {&#10;            String requestId = UUID.randomUUID().toString();&#10;            CompletableFuture&lt;Response&gt; future = new CompletableFuture&lt;&gt;();&#10;            ResponseManager.register(requestId, future);&#10;            Sender.sender.fetchChat(chatId, requestId);&#10;&#10;            CompletableFuture&lt;Response&gt; chainedFuture = future.thenCompose(res -&gt; {&#10;                if (res.getStatusCode() == 200) {&#10;                    Chat chat = (Chat) res.getBody();&#10;                    allChats.put(chatId, chat);&#10;                  chat.printMessages();&#10;                    String receiverPhone = ReceiverPhone.get(chat);&#10;                    receiverMap.put(receiverPhone, chatId);&#10;&#10;                    // Now fetch the receiver user&#10;                    String userReqId = UUID.randomUUID().toString();&#10;                    CompletableFuture&lt;Response&gt; userFuture = new CompletableFuture&lt;&gt;();&#10;                    ResponseManager.register(userReqId, userFuture);&#10;                    System.out.println(&quot;receiverPhone = &quot; + receiverPhone);&#10;                    Sender.sender.searchSingle(receiverPhone, userReqId);&#10;&#10;                    return userFuture.thenApply(userRes -&gt; {&#10;                        System.out.println(&quot;fetching user for phone: &quot; + receiverPhone);&#10;                        if (userRes.getStatusCode() == 200) {&#10;                            User receiver = (User) userRes.getBody();&#10;                        System.out.println(userRes.getStatusCode());&#10;                            System.out.println(&quot;Fetched user: &quot; + receiver.getName());&#10;                            addOrUpdateUser(receiver); // Add to ChatController.allChatUser&#10;                        } else {&#10;                            System.err.println(&quot;❌ Failed to fetch user for phone: &quot; + receiverPhone);&#10;                        }&#10;                        return userRes;&#10;                    });&#10;                } else {&#10;                    System.err.println(&quot;❌ Failed to fetch chat for chatId: &quot; + chatId);&#10;                    return CompletableFuture.completedFuture(res);&#10;                }&#10;            });&#10;&#10;            futures.add(chainedFuture);&#10;        }&#10;&#10;//  Run after ALL chats + users are fetched&#10;        CompletableFuture&#10;                .allOf(futures.toArray(new CompletableFuture[0]))&#10;                .thenRun(() -&gt; Platform.runLater(this::populateChatList));&#10;&#10;&#10;&#10;&#10;&#10;    }&#10;&#10;//    @FXML&#10;//    private void onSearchClicked() {&#10;//&#10;//    }&#10;//&#10;//    /** Clears the search field when the “×” button is clicked. */&#10;//    @FXML&#10;//    private void onClearSearchClicked() {&#10;//        searchField.clear();&#10;//    }&#10;&#10;    /**&#10;     * Use javafx.scene.input.KeyEvent, not AWT KeyEvent&#10;     */&#10;&#10;&#10;    /**&#10;     * Use javafx.event.ActionEvent, not AWT ActionEvent&#10;     */&#10;    @FXML&#10;    private void onSettingsClicked(ActionEvent event) {&#10;        try {&#10;            // Load the login page&#10;            FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;/views/settings.fxml&quot;));&#10;            Parent root = loader.load();&#10;            Scene scene = new Scene(root, 1000, 600);&#10;            Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();&#10;            stage.setScene(scene);&#10;            stage.show();&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void onSearchClicked(ActionEvent mouseEvent) {&#10;        String query = searchField.getText().trim();&#10;        List&lt;User&gt; foundUsers;&#10;        if (!query.isEmpty()) {&#10;&#10;            // Create a request ID&#10;            String requestId = UUID.randomUUID().toString();&#10;&#10;            // Create future &amp; register it&#10;            CompletableFuture&lt;Response&gt; asyncResponse = new CompletableFuture&lt;&gt;();&#10;            ResponseManager.register(requestId, asyncResponse);&#10;&#10;            Sender.sender.searchUser(query, requestId);&#10;&#10;            asyncResponse.thenApply((res) -&gt; {&#10;&#10;                System.out.println(res);&#10;                if (res.getStatusCode() != 200) {&#10;//                Platform.runLater(() -&gt; showError(&quot;Invalid phone number or password&quot;));&#10;                } else {&#10;                    Platform.runLater(() -&gt; {&#10;&#10;                     showSearchResults ((List&lt;User&gt;) res.getBody());&#10;                    });&#10;&#10;&#10;                }&#10;&#10;                return res;&#10;            });&#10;        }&#10;&#10;&#10;    }&#10;&#10;    public void onClearSearchClicked(MouseEvent mouseEvent) {&#10;        searchField.clear();&#10;        populateChatList();&#10;    }&#10;&#10;    public void showSearchResults(List&lt;User&gt; users) {&#10;        chatList.getChildren().clear();&#10;        if (users.isEmpty()) {&#10;            Label label = new Label(&quot;User not found&quot;);&#10;            label.setStyle(&quot;-fx-text-fill: red;&quot;);&#10;            label.setAlignment(Pos.CENTER);&#10;            chatList.getChildren().add(label);&#10;        }&#10;&#10;&#10;        for (User user : users) {&#10;&#10;            System.out.println(user);&#10;&#10;            HBox hbox = new HBox();&#10;            hbox.setAlignment(Pos.CENTER);&#10;            hbox.setPrefWidth(334);&#10;            hbox.setPrefHeight(72);&#10;            ImageView avatar = new ImageView(Base64ImageHelper.getImageViewFromBase64(user.getUrl()));&#10;            avatar.setFitWidth(55);&#10;            avatar.setFitHeight(50);&#10;            VBox vbox = new VBox();&#10;            vbox.setPrefWidth(231);&#10;            vbox.setPrefHeight(100);&#10;            Label nameLabel = new Label(user.getName());&#10;            nameLabel.setPrefWidth(131);&#10;            nameLabel.setPrefHeight(35);&#10;            nameLabel.setFont(Font.font(&quot;System&quot;, FontWeight.BOLD, 16));&#10;            VBox.setMargin(nameLabel, new Insets(8, 0, 0, 0));&#10;            nameLabel.setAlignment(Pos.CENTER);&#10;            Label messageLabel = new Label(&quot;Click to message&quot;);&#10;            messageLabel.setPrefWidth(227);&#10;            messageLabel.setPrefHeight(18);&#10;            VBox.setMargin(messageLabel, new Insets(0, 0, 0, 0));&#10;            messageLabel.setPadding(new Insets(0, 0, 0, 15));&#10;            messageLabel.setAlignment(Pos.TOP_LEFT);&#10;            vbox.getChildren().addAll(nameLabel, messageLabel);&#10;            hbox.getChildren().addAll(avatar, vbox);&#10;            hbox.setId(user.getPhone());&#10;            hbox.setOnMouseClicked((event) -&gt; {&#10;                startChat(event,user);&#10;            });&#10;            chatList.getChildren().add(hbox);&#10;        }&#10;&#10;&#10;    }&#10;&#10;    public void startChat(MouseEvent mouseEvent, User user) {&#10;//        System.out.println(&quot;startChat with&quot;+phone);&#10;//&#10;//        Sender.sender.sendMessage(phone,&quot;initializing chat&quot;,&quot;null&quot;);&#10;            receiverImage.setImage(Base64ImageHelper.getImageViewFromBase64(user.getUrl()));&#10;            receiverName.setText(user.getName());&#10;            currentReceiverPhone = user.getPhone();&#10;            // check if already has conversation to this user&#10;            Integer chatId = receiverMap.get(user.getPhone());&#10;&#10;            if(chatId != null) {&#10;                hadChat = true;&#10;                currentChatId=chatId;&#10;                populateChat(allChats.get(chatId));&#10;            }else{&#10;                hadChat = false;&#10;            }&#10;&#10;            populateChatList();&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    }&#10;&#10;&#10;    public void populateChat(Chat chat)&#10;    {&#10;        messageContainer.getChildren().clear();&#10;&#10;        for (Message msg:chat.getMessages())&#10;        {&#10;            // checking its my message or not&#10;            boolean mine= msg.getSender().equals(SignedUser.phone);&#10;            addMessageBubble(msg.getMessage(),mine);&#10;        }&#10;    }&#10;&#10;&#10;    @FXML&#10;    public void onSendClicked(ActionEvent event) {&#10;&#10;//        if (currentChatPhone == null) return;&#10;&#10;        String text = messageField.getText().trim();&#10;&#10;        if (text.isEmpty()) return;&#10;        Message msg = new Message(SignedUser.phone,currentReceiverPhone, System.currentTimeMillis() / 1000L,text);&#10;        if(!hadChat) {&#10;            System.out.println(&quot;first message&quot;);&#10;            msg.setFirstMsg(true);&#10;&#10;        }&#10;        else{&#10;            System.out.println(&quot;not first message&quot;);&#10;            msg.setChatId(currentChatId);&#10;        }&#10;        // Create a request ID&#10;        String requestId = UUID.randomUUID().toString();&#10;&#10;        // Create future &amp; register it&#10;        CompletableFuture&lt;Response&gt; asyncResponse = new CompletableFuture&lt;&gt;();&#10;        ResponseManager.register(requestId, asyncResponse);&#10;&#10;        // 1) send to server&#10;        Sender.sender.sendMessage( msg ,requestId);&#10;&#10;        asyncResponse.thenApply((res) -&gt; {&#10;            System.out.println(&quot;hiiiiiiiiiiiiii&quot;);&#10;            Chat chat =(Chat) res.getBody();&#10;&#10;            if (res.getStatusCode() != 200) {&#10;//                Platform.runLater(() -&gt; showError(&quot;Invalid phone number or password&quot;));&#10;            } else {&#10;                Platform.runLater(() -&gt; {&#10;&#10;                    allChats.put(chat.getChatId(),chat);&#10;                    populateChatList();&#10;                    System.out.println(chat.getChatId());&#10;                    SignedUser.chatList.add(chat.getChatId());&#10;                    SignedUser.saveToFile();&#10;                });&#10;&#10;&#10;            }&#10;&#10;            return res;&#10;        });&#10;&#10;&#10;        // 2) echo locally&#10;        addMessageBubble(text, true);&#10;&#10;        // 3) clear input &amp; scroll to bottom&#10;        messageField.clear();&#10;        Platform.runLater(() -&gt; messageScrollPane.setVvalue(1.0));&#10;&#10;    }&#10;&#10;    public void onDotsClicked() {&#10;        blockUserButton.setVisible(false);&#10;        dotsMenu.show(dotsButton, Side.BOTTOM, 0, 0);&#10;    }&#10;&#10;    public void onBlockUserClicked() {&#10;        System.out.println(&quot;Blocking user...&quot;);&#10;        // ... your block‐user code here ...&#10;        try {&#10;            new Page().Goto(Pages.BLOCK);&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;        // then hide the menu&#10;        dotsMenu.hide();&#10;    }&#10;&#10;    public void addMessageBubble(String text, boolean mine) {&#10;&#10;        HBox messageContainer = new HBox();&#10;        messageContainer.setAlignment(mine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);&#10;        messageContainer.setPadding(new Insets(5, 10, 5, 10));&#10;&#10;        TextFlow messageBubble = new TextFlow();&#10;        messageBubble.setPadding(new Insets(10));&#10;        messageBubble.setStyle(mine ? &quot;-fx-background-color: #0084ff; -fx-background-radius: 15 0 15 15;&quot; : &quot;-fx-background-color: #e4e6eb; -fx-background-radius: 0 15 15 15;&quot;);&#10;&#10;        Text messageText = new Text(text);&#10;        messageText.setStyle(&quot;-fx-fill: &quot; + (mine ? &quot;white&quot; : &quot;black&quot;) + &quot;; -fx-font-size: 14;&quot;);&#10;        messageBubble.getChildren().add(messageText);&#10;&#10;        // Add timestamp&#10;        Label timeLabel = new Label(LocalTime.now().format(DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)));&#10;        timeLabel.setStyle(&quot;-fx-text-fill: &quot; + (mine ? &quot;#aad4ff&quot; : &quot;#666&quot;) + &quot;; -fx-font-size: 10;&quot;);&#10;&#10;        VBox messageContent = new VBox(5, messageBubble, timeLabel);&#10;        messageContent.setAlignment(mine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);&#10;&#10;        messageContainer.getChildren().add(messageContent);&#10;        this.messageContainer.getChildren().add(messageContainer);&#10;    }&#10;&#10;&#10;    public void populateChatList() {&#10;        chatList.getChildren().clear();&#10;&#10;        for (int chatId : SignedUser.chatList) {&#10;            System.out.println(&quot;populateChatList for chatId: &quot; + chatId);&#10;&#10;            // Safely get the phone (key) from chatId&#10;            String phone = MapUtils.getKeyFromValue(receiverMap, chatId);&#10;&#10;            if (phone == null) {&#10;                System.err.println(&quot;No phone found for chatId: &quot; + chatId);&#10;                continue; // skip this chatId&#10;            }&#10;&#10;            User user = FindUser.findUserByPhone(allChatUser, phone);&#10;&#10;//            if (user == null) {&#10;//&#10;//&#10;//            String requestId = UUID.randomUUID().toString();&#10;//&#10;//            // Create future &amp; register it&#10;//            CompletableFuture&lt;Response&gt; asyncResponse = new CompletableFuture&lt;&gt;();&#10;//            ResponseManager.register(requestId, asyncResponse);&#10;//&#10;//            Sender.sender.searchSingle(phone, requestId);&#10;//&#10;//                asyncResponse.thenApply((res) -&gt; {&#10;//                    System.out.println(&quot;hiiiiiiiiiiiiii&quot;);&#10;//                    Chat chat =(Chat) res.getBody();&#10;//&#10;//                    if (res.getStatusCode() != 200) {&#10;////                Platform.runLater(() -&gt; showError(&quot;Invalid phone number or password&quot;));&#10;//                    } else {&#10;//                        Platform.runLater(() -&gt; {&#10;//&#10;//                            User foundUser = (User) res.getBody();&#10;//                            SignedUser.saveToFile();&#10;//                        });&#10;//&#10;//&#10;//                    }&#10;//&#10;//                    return res;&#10;//                });&#10;//&#10;//&#10;//            }&#10;&#10;            // Build UI node&#10;            HBox hbox = new HBox();&#10;            hbox.setAlignment(Pos.CENTER);&#10;            hbox.setPrefWidth(334);&#10;            hbox.setPrefHeight(72);&#10;&#10;            ImageView avatar = new ImageView(Base64ImageHelper.getImageViewFromBase64(user.getUrl()));&#10;            avatar.setFitWidth(55);&#10;            avatar.setFitHeight(50);&#10;&#10;            VBox vbox = new VBox();&#10;            vbox.setPrefWidth(231);&#10;            vbox.setPrefHeight(100);&#10;&#10;            Label nameLabel = new Label(user.getName());&#10;            nameLabel.setPrefWidth(131);&#10;            nameLabel.setPrefHeight(35);&#10;            nameLabel.setFont(Font.font(&quot;System&quot;, FontWeight.BOLD, 16));&#10;            VBox.setMargin(nameLabel, new Insets(8, 0, 0, 0));&#10;            nameLabel.setAlignment(Pos.CENTER);&#10;&#10;            Label messageLabel = new Label(&quot;Click to message&quot;);&#10;            messageLabel.setPrefWidth(227);&#10;            messageLabel.setPrefHeight(18);&#10;            VBox.setMargin(messageLabel, new Insets(0, 0, 0, 0));&#10;            messageLabel.setPadding(new Insets(0, 0, 0, 15));&#10;            messageLabel.setAlignment(Pos.TOP_LEFT);&#10;&#10;            vbox.getChildren().addAll(nameLabel, messageLabel);&#10;            hbox.getChildren().addAll(avatar, vbox);&#10;&#10;            hbox.setId(user.getPhone());&#10;            hbox.setOnMouseClicked(event -&gt; startChat(event, user));&#10;&#10;            chatList.getChildren().add(hbox);&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.client.chat;&#10;&#10;//import com.fasterxml.jackson.core.json.DupDetector;&#10;&#10;&#10;import com.api.ResponseManager;&#10;import com.api.Sender;&#10;import com.client.util.*;&#10;//import com.db.ClientChat;&#10;import com.db.*;&#10;import com.server.Response;&#10;import javafx.application.Platform;&#10;import javafx.beans.binding.Bindings;&#10;import javafx.event.ActionEvent;            // ← JavaFX ActionEvent&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Pos;&#10;import javafx.geometry.Side;&#10;import javafx.scene.Node;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.*;&#10;import javafx.scene.image.Image;&#10;import javafx.scene.image.ImageView;&#10;import javafx.scene.input.MouseEvent;&#10;import javafx.scene.layout.HBox;&#10;import javafx.scene.layout.VBox;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.text.FontWeight;&#10;import javafx.scene.text.Text;&#10;import javafx.scene.text.TextFlow;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;import java.time.LocalTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;public class ChatController {&#10;    @FXML&#10;    public Button settingsButton;&#10;    @FXML&#10;    private ImageView searchIcon;&#10;    @FXML&#10;    private TextField searchField;&#10;    @FXML&#10;    private ImageView clearSearch;&#10;    @FXML&#10;    private VBox contactsBox;&#10;    @FXML&#10;    private VBox chatList;&#10;    private int chatId;&#10;&#10;    @FXML&#10;&#10;    private Button dotsButton;&#10;&#10;    @FXML&#10;&#10;    private Button blockUserButton;  // we'll still call this if you want to reuse its handler&#10;&#10;    @FXML&#10;    private ImageView userImage;&#10;    @FXML&#10;    private Label userName;&#10;&#10;&#10;    // our ContextMenu and MenuItem&#10;    @FXML&#10;    private ContextMenu dotsMenu;&#10;    @FXML&#10;    private MenuItem blockUserItem;&#10;    @FXML&#10;    private String currentChatPhone;&#10;&#10;    @FXML&#10;    private ImageView sendIcon;&#10;    @FXML&#10;    private TextField messageField;&#10;    @FXML&#10;    private ScrollPane messageScrollPane;&#10;    @FXML&#10;    private VBox messageContainer;&#10;    // its content VBox&#10;    @FXML&#10;    private ImageView headerAvatar;            // the avatar in the header bar&#10;    @FXML&#10;    private Label headerNameLabel;           // the username in the header bar// bottom “write here…” TextField&#10;    @FXML&#10;    private Button sendButton;&#10;    @FXML&#10;    private Label receiverName;&#10;    @FXML&#10;    private ImageView receiverImage;&#10;&#10;    // maps receiver phone to chat id&#10;    public static Map&lt;String,Integer&gt; receiverMap;&#10;    //&#10;    boolean hadChat = false;&#10;    public static Integer currentChatId=null;&#10;    private String currentReceiverPhone;&#10;    public static List&lt;User&gt; allChatUser;&#10;//    private List&lt;ClientChat&gt; chats;&#10;&#10;&#10;    public static Map&lt;Integer, Chat&gt; allChats = new HashMap&lt;&gt;();&#10;&#10;&#10;    public static void addOrUpdateUser(User user) {&#10;        for (int i = 0; i &lt; allChatUser.size(); i++) {&#10;            if (allChatUser.get(i).getPhone().equals(user.getPhone())) {&#10;                allChatUser.set(i, user); // update&#10;                return;&#10;            }&#10;        }&#10;        allChatUser.add(user); // add if not found&#10;    }&#10;&#10;    public static Optional&lt;User&gt; findUser(String phone) {&#10;        return allChatUser.stream()&#10;                .filter(u -&gt; u.getPhone().equals(phone))&#10;                .findFirst();&#10;    }&#10;&#10;    /**&#10;     * This must be annotated @FXML so FXMLLoader sees it.&#10;     */&#10;    @FXML&#10;    private void initialize() {&#10;        allChatUser= new ArrayList&lt;&gt;();&#10;        // optional setup after FXML is loaded&#10;        settingsButton.setOnAction(this::onSettingsClicked);&#10;&#10;&#10;        clearSearch.visibleProperty().bind(&#10;                Bindings.createBooleanBinding(&#10;                        () -&gt; !searchField.getText().trim().isEmpty(),&#10;                        searchField.textProperty()&#10;                )&#10;        );&#10;&#10;        // also remove it from layout when invisible&#10;        clearSearch.managedProperty().bind(clearSearch.visibleProperty());&#10;&#10;        // so that clicks through the transparent area don't block typing&#10;&#10;        clearSearch.visibleProperty().bind(searchField.textProperty().isNotEmpty());&#10;        clearSearch.managedProperty().bind(clearSearch.visibleProperty());&#10;        clearSearch.mouseTransparentProperty().bind(clearSearch.visibleProperty().not());&#10;        clearSearch.setPickOnBounds(false);&#10;//        searchIcon.setPickOnBounds(false);&#10;&#10;        // build the popup menu&#10;        dotsMenu = new ContextMenu();&#10;        blockUserItem = new MenuItem(&quot;Block User&quot;);&#10;        dotsMenu.getItems().add(blockUserItem);&#10;&#10;        // what happens when &quot;Block User&quot; is clicked&#10;        blockUserItem.setOnAction(e -&gt; {&#10;            onBlockUserClicked();&#10;        });&#10;&#10;        userName.setText(SignedUser.name);&#10;//        Base64ImageHelper.getImageViewFromBase64(userImage,SignedUser.url,50,50);&#10;//        System.out.println(SignedUser.url);&#10;        userImage.setImage(Base64ImageHelper.getImageViewFromBase64(SignedUser.url));&#10;        // load all chats from file&#10;&#10;//        loadAllChat();&#10;        receiverMap = new HashMap&lt;&gt;();&#10;        // loading all chats&#10;        List&lt;CompletableFuture&lt;Response&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;&#10;        for (int chatId : SignedUser.chatList) {&#10;            String requestId = UUID.randomUUID().toString();&#10;            CompletableFuture&lt;Response&gt; future = new CompletableFuture&lt;&gt;();&#10;            ResponseManager.register(requestId, future);&#10;            Sender.sender.fetchChat(chatId, requestId);&#10;&#10;            CompletableFuture&lt;Response&gt; chainedFuture = future.thenCompose(res -&gt; {&#10;                if (res.getStatusCode() == 200) {&#10;                    Chat chat = (Chat) res.getBody();&#10;                    allChats.put(chatId, chat);&#10;                  chat.printMessages();&#10;                    String receiverPhone = ReceiverPhone.get(chat);&#10;                    receiverMap.put(receiverPhone, chatId);&#10;&#10;                    // Now fetch the receiver user&#10;                    String userReqId = UUID.randomUUID().toString();&#10;                    CompletableFuture&lt;Response&gt; userFuture = new CompletableFuture&lt;&gt;();&#10;                    ResponseManager.register(userReqId, userFuture);&#10;                    System.out.println(&quot;receiverPhone = &quot; + receiverPhone);&#10;                    Sender.sender.searchSingle(receiverPhone, userReqId);&#10;&#10;                    return userFuture.thenApply(userRes -&gt; {&#10;                        System.out.println(&quot;fetching user for phone: &quot; + receiverPhone);&#10;                        if (userRes.getStatusCode() == 200) {&#10;                            User receiver = (User) userRes.getBody();&#10;                        System.out.println(userRes.getStatusCode());&#10;                            System.out.println(&quot;Fetched user: &quot; + receiver.getName());&#10;                            addOrUpdateUser(receiver); // Add to ChatController.allChatUser&#10;                        } else {&#10;                            System.err.println(&quot;❌ Failed to fetch user for phone: &quot; + receiverPhone);&#10;                        }&#10;                        return userRes;&#10;                    });&#10;                } else {&#10;                    System.err.println(&quot;❌ Failed to fetch chat for chatId: &quot; + chatId);&#10;                    return CompletableFuture.completedFuture(res);&#10;                }&#10;            });&#10;&#10;            futures.add(chainedFuture);&#10;        }&#10;&#10;//  Run after ALL chats + users are fetched&#10;        CompletableFuture&#10;                .allOf(futures.toArray(new CompletableFuture[0]))&#10;                .thenRun(() -&gt; Platform.runLater(this::populateChatList));&#10;&#10;&#10;&#10;&#10;&#10;    }&#10;&#10;//    @FXML&#10;//    private void onSearchClicked() {&#10;//&#10;//    }&#10;//&#10;//    /** Clears the search field when the “×” button is clicked. */&#10;//    @FXML&#10;//    private void onClearSearchClicked() {&#10;//        searchField.clear();&#10;//    }&#10;&#10;    /**&#10;     * Use javafx.scene.input.KeyEvent, not AWT KeyEvent&#10;     */&#10;&#10;&#10;    /**&#10;     * Use javafx.event.ActionEvent, not AWT ActionEvent&#10;     */&#10;    @FXML&#10;    private void onSettingsClicked(ActionEvent event) {&#10;        try {&#10;            // Load the login page&#10;            FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;/views/settings.fxml&quot;));&#10;            Parent root = loader.load();&#10;            Scene scene = new Scene(root, 1000, 600);&#10;            Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();&#10;            stage.setScene(scene);&#10;            stage.show();&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void onSearchClicked(ActionEvent mouseEvent) {&#10;        String query = searchField.getText().trim();&#10;        List&lt;User&gt; foundUsers;&#10;        if (!query.isEmpty()) {&#10;&#10;            // Create a request ID&#10;            String requestId = UUID.randomUUID().toString();&#10;&#10;            // Create future &amp; register it&#10;            CompletableFuture&lt;Response&gt; asyncResponse = new CompletableFuture&lt;&gt;();&#10;            ResponseManager.register(requestId, asyncResponse);&#10;&#10;            Sender.sender.searchUser(query, requestId);&#10;&#10;            asyncResponse.thenApply((res) -&gt; {&#10;&#10;                System.out.println(res);&#10;                if (res.getStatusCode() != 200) {&#10;//                Platform.runLater(() -&gt; showError(&quot;Invalid phone number or password&quot;));&#10;                } else {&#10;                    Platform.runLater(() -&gt; {&#10;&#10;                     showSearchResults ((List&lt;User&gt;) res.getBody());&#10;                    });&#10;&#10;&#10;                }&#10;&#10;                return res;&#10;            });&#10;        }&#10;&#10;&#10;    }&#10;&#10;    public void onClearSearchClicked(MouseEvent mouseEvent) {&#10;        searchField.clear();&#10;        populateChatList();&#10;    }&#10;&#10;    public void showSearchResults(List&lt;User&gt; users) {&#10;        chatList.getChildren().clear();&#10;        if (users.isEmpty()) {&#10;            Label label = new Label(&quot;User not found&quot;);&#10;            label.setStyle(&quot;-fx-text-fill: red;&quot;);&#10;            label.setAlignment(Pos.CENTER);&#10;            chatList.getChildren().add(label);&#10;        }&#10;&#10;&#10;        for (User user : users) {&#10;&#10;            System.out.println(user);&#10;&#10;            HBox hbox = new HBox();&#10;            hbox.setAlignment(Pos.CENTER);&#10;            hbox.setPrefWidth(334);&#10;            hbox.setPrefHeight(72);&#10;            ImageView avatar = new ImageView(Base64ImageHelper.getImageViewFromBase64(user.getUrl()));&#10;            avatar.setFitWidth(55);&#10;            avatar.setFitHeight(50);&#10;            VBox vbox = new VBox();&#10;            vbox.setPrefWidth(231);&#10;            vbox.setPrefHeight(100);&#10;            Label nameLabel = new Label(user.getName());&#10;            nameLabel.setPrefWidth(131);&#10;            nameLabel.setPrefHeight(35);&#10;            nameLabel.setFont(Font.font(&quot;System&quot;, FontWeight.BOLD, 16));&#10;            VBox.setMargin(nameLabel, new Insets(8, 0, 0, 0));&#10;            nameLabel.setAlignment(Pos.CENTER);&#10;            Label messageLabel = new Label(&quot;Click to message&quot;);&#10;            messageLabel.setPrefWidth(227);&#10;            messageLabel.setPrefHeight(18);&#10;            VBox.setMargin(messageLabel, new Insets(0, 0, 0, 0));&#10;            messageLabel.setPadding(new Insets(0, 0, 0, 15));&#10;            messageLabel.setAlignment(Pos.TOP_LEFT);&#10;            vbox.getChildren().addAll(nameLabel, messageLabel);&#10;            hbox.getChildren().addAll(avatar, vbox);&#10;            hbox.setId(user.getPhone());&#10;            hbox.setOnMouseClicked((event) -&gt; {&#10;                startChat(event,user);&#10;            });&#10;            chatList.getChildren().add(hbox);&#10;        }&#10;&#10;&#10;    }&#10;&#10;    public void startChat(MouseEvent mouseEvent, User user) {&#10;        receiverImage.setImage(Base64ImageHelper.getImageViewFromBase64(user.getUrl()));&#10;        receiverName.setText(user.getName());&#10;        currentReceiverPhone = user.getPhone();&#10;        Integer chatId = receiverMap.get(user.getPhone());&#10;&#10;        // Clear message container when switching chats&#10;        messageContainer.getChildren().clear();&#10;&#10;        if(chatId != null) {&#10;            hadChat = true;&#10;            currentChatId=chatId;&#10;            populateChat(allChats.get(chatId));&#10;        }else{&#10;            hadChat = false;&#10;        }&#10;&#10;        populateChatList();&#10;    }&#10;&#10;    public void populateChat(Chat chat)&#10;    {&#10;        messageContainer.getChildren().clear();&#10;        Set&lt;String&gt; shownMessages = new HashSet&lt;&gt;();&#10;        for (Message msg:chat.getMessages())&#10;        {&#10;            // Prevent duplicate messages&#10;            String msgKey = msg.getSender() + msg.getTimestamp() + msg.getMessage();&#10;            if (shownMessages.contains(msgKey)) continue;&#10;            shownMessages.add(msgKey);&#10;&#10;            boolean mine= msg.getSender().equals(SignedUser.phone);&#10;            addMessageBubble(msg.getMessage(),mine);&#10;        }&#10;    }&#10;&#10;&#10;    @FXML&#10;    public void onSendClicked(ActionEvent event) {&#10;&#10;//        if (currentChatPhone == null) return;&#10;&#10;        String text = messageField.getText().trim();&#10;&#10;        if (text.isEmpty()) return;&#10;        Message msg = new Message(SignedUser.phone,currentReceiverPhone, System.currentTimeMillis() / 1000L,text);&#10;        if(!hadChat) {&#10;            System.out.println(&quot;first message&quot;);&#10;            msg.setFirstMsg(true);&#10;&#10;        }&#10;        else{&#10;            System.out.println(&quot;not first message&quot;);&#10;            msg.setChatId(currentChatId);&#10;        }&#10;        // Create a request ID&#10;        String requestId = UUID.randomUUID().toString();&#10;&#10;        // Create future &amp; register it&#10;        CompletableFuture&lt;Response&gt; asyncResponse = new CompletableFuture&lt;&gt;();&#10;        ResponseManager.register(requestId, asyncResponse);&#10;&#10;        // 1) send to server&#10;        Sender.sender.sendMessage( msg ,requestId);&#10;&#10;        asyncResponse.thenApply((res) -&gt; {&#10;            System.out.println(&quot;hiiiiiiiiiiiiii&quot;);&#10;            Chat chat =(Chat) res.getBody();&#10;&#10;            if (res.getStatusCode() != 200) {&#10;//                Platform.runLater(() -&gt; showError(&quot;Invalid phone number or password&quot;));&#10;            } else {&#10;                Platform.runLater(() -&gt; {&#10;&#10;                    allChats.put(chat.getChatId(),chat);&#10;                    populateChatList();&#10;                    System.out.println(chat.getChatId());&#10;                    SignedUser.chatList.add(chat.getChatId());&#10;                    SignedUser.saveToFile();&#10;                });&#10;&#10;&#10;            }&#10;&#10;            return res;&#10;        });&#10;&#10;&#10;        // 2) echo locally&#10;        addMessageBubble(text, true);&#10;&#10;        // 3) clear input &amp; scroll to bottom&#10;        messageField.clear();&#10;        Platform.runLater(() -&gt; messageScrollPane.setVvalue(1.0));&#10;&#10;    }&#10;&#10;    public void onDotsClicked() {&#10;        blockUserButton.setVisible(false);&#10;        dotsMenu.show(dotsButton, Side.BOTTOM, 0, 0);&#10;    }&#10;&#10;    public void onBlockUserClicked() {&#10;        System.out.println(&quot;Blocking user...&quot;);&#10;        // ... your block‐user code here ...&#10;        try {&#10;            new Page().Goto(Pages.BLOCK);&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;        // then hide the menu&#10;        dotsMenu.hide();&#10;    }&#10;&#10;    public void addMessageBubble(String text, boolean mine) {&#10;&#10;        HBox messageContainer = new HBox();&#10;        messageContainer.setAlignment(mine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);&#10;        messageContainer.setPadding(new Insets(5, 10, 5, 10));&#10;&#10;        TextFlow messageBubble = new TextFlow();&#10;        messageBubble.setPadding(new Insets(10));&#10;        messageBubble.setStyle(mine ? &quot;-fx-background-color: #0084ff; -fx-background-radius: 15 0 15 15;&quot; : &quot;-fx-background-color: #e4e6eb; -fx-background-radius: 0 15 15 15;&quot;);&#10;&#10;        Text messageText = new Text(text);&#10;        messageText.setStyle(&quot;-fx-fill: &quot; + (mine ? &quot;white&quot; : &quot;black&quot;) + &quot;; -fx-font-size: 14;&quot;);&#10;        messageBubble.getChildren().add(messageText);&#10;&#10;        // Add timestamp&#10;        Label timeLabel = new Label(LocalTime.now().format(DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)));&#10;        timeLabel.setStyle(&quot;-fx-text-fill: &quot; + (mine ? &quot;#aad4ff&quot; : &quot;#666&quot;) + &quot;; -fx-font-size: 10;&quot;);&#10;&#10;        VBox messageContent = new VBox(5, messageBubble, timeLabel);&#10;        messageContent.setAlignment(mine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);&#10;&#10;        messageContainer.getChildren().add(messageContent);&#10;        this.messageContainer.getChildren().add(messageContainer);&#10;    }&#10;&#10;&#10;    public void populateChatList() {&#10;        chatList.getChildren().clear();&#10;&#10;        for (int chatId : SignedUser.chatList) {&#10;            String phone = MapUtils.getKeyFromValue(receiverMap, chatId);&#10;&#10;            if (phone == null) {&#10;                System.err.println(&quot;No phone found for chatId: &quot; + chatId);&#10;                continue;&#10;            }&#10;&#10;            User user = FindUser.findUserByPhone(allChatUser, phone);&#10;            if (user == null) {&#10;                // Skip if user not found&#10;                continue;&#10;            }&#10;&#10;            HBox hbox = new HBox();&#10;            hbox.setAlignment(Pos.CENTER);&#10;            hbox.setPrefWidth(334);&#10;            hbox.setPrefHeight(72);&#10;&#10;            ImageView avatar = new ImageView(Base64ImageHelper.getImageViewFromBase64(user.getUrl()));&#10;            avatar.setFitWidth(55);&#10;            avatar.setFitHeight(50);&#10;&#10;            VBox vbox = new VBox();&#10;            vbox.setPrefWidth(231);&#10;            vbox.setPrefHeight(100);&#10;&#10;            Label nameLabel = new Label(user.getName());&#10;            nameLabel.setPrefWidth(131);&#10;            nameLabel.setPrefHeight(35);&#10;            nameLabel.setFont(Font.font(&quot;System&quot;, FontWeight.BOLD, 16));&#10;            VBox.setMargin(nameLabel, new Insets(8, 0, 0, 0));&#10;            nameLabel.setAlignment(Pos.CENTER);&#10;&#10;            Label messageLabel = new Label(&quot;Click to message&quot;);&#10;            messageLabel.setPrefWidth(227);&#10;            messageLabel.setPrefHeight(18);&#10;            VBox.setMargin(messageLabel, new Insets(0, 0, 0, 0));&#10;            messageLabel.setPadding(new Insets(0, 0, 0, 15));&#10;            messageLabel.setAlignment(Pos.TOP_LEFT);&#10;&#10;            vbox.getChildren().addAll(nameLabel, messageLabel);&#10;            hbox.getChildren().addAll(avatar, vbox);&#10;&#10;            hbox.setId(user.getPhone());&#10;            hbox.setOnMouseClicked(event -&gt; startChat(event, user));&#10;&#10;            chatList.getChildren().add(hbox);&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/src/main/java/com/Server.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/src/main/java/com/Server.java" />
              <option name="originalContent" value="package com;&#10;&#10;//import com.controller.ClientHandlerNew;&#10;import com.controller.ClientHandler;&#10;import com.db.Chat;&#10;import com.db.User;&#10;&#10;import java.io.IOException;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class Server{&#10;    public static void main(String[] args) {&#10;        // loading all user data from file&#10;        User.loadFromFile();&#10;        Chat.loadAllChats();&#10;        HashMap&lt;String,Socket&gt; clientMap = new HashMap&lt;&gt;();&#10;&#10;        ExecutorService executorService = Executors.newCachedThreadPool();&#10;        int clientNum = 1;&#10;        while(true){&#10;&#10;&#10;        try(ServerSocket serverSocket = new ServerSocket(5000)){&#10;            System.out.println(&quot;waiting for client ...&quot;);&#10;            Socket socket  = serverSocket.accept(); // blocking call&#10;            System.out.println(&quot;Server accepts &quot;+(clientNum++)+&quot; client connection&quot;);&#10;&#10;            ClientHandler clientHandler = new ClientHandler(socket,clientMap);&#10;            executorService.submit(clientHandler::router);&#10;        }&#10;&#10;&#10;&#10;        catch (IOException e){&#10;            System.out.println(&quot;Client not listening&quot;);&#10;        }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com;&#13;&#10;&#13;&#10;//import com.controller.ClientHandlerNew;&#13;&#10;import com.controller.ClientHandler;&#13;&#10;import com.db.Chat;&#13;&#10;import com.db.User;&#13;&#10;&#13;&#10;import java.io.IOException;&#13;&#10;import java.net.ServerSocket;&#13;&#10;import java.net.Socket;&#13;&#10;import java.util.HashMap;&#13;&#10;import java.util.concurrent.ExecutorService;&#13;&#10;import java.util.concurrent.Executors;&#13;&#10;&#13;&#10;public class Server{&#13;&#10;    public static void main(String[] args) {&#13;&#10;        // loading all user data from file&#13;&#10;        User.loadFromFile();&#13;&#10;        Chat.loadAllChats();&#13;&#10;        HashMap&lt;String,Socket&gt; clientMap = new HashMap&lt;&gt;();&#13;&#10;        ExecutorService executorService = Executors.newCachedThreadPool();&#13;&#10;        int clientNum = 1;&#13;&#10;&#13;&#10;        try (ServerSocket serverSocket = new ServerSocket(5000)) {&#13;&#10;            System.out.println(&quot;waiting for client ...&quot;);&#13;&#10;            while (true) {&#13;&#10;                Socket socket  = serverSocket.accept(); // blocking call&#13;&#10;                System.out.println(&quot;Server accepts &quot;+(clientNum++)+&quot; client connection&quot;);&#13;&#10;                ClientHandler clientHandler = new ClientHandler(socket,clientMap);&#13;&#10;                executorService.submit(clientHandler::router);&#13;&#10;            }&#13;&#10;        } catch (IOException e){&#13;&#10;            System.out.println(&quot;Client not listening&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/src/main/java/com/controller/ClientHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/src/main/java/com/controller/ClientHandler.java" />
              <option name="originalContent" value="package com.controller;&#10;&#10;import com.api.Data;&#10;import com.db.Chat;&#10;import com.db.Message;&#10;import com.db.User;&#10;import com.server.Response;&#10;&#10;import java.io.*;&#10;import java.net.Socket;&#10;import java.util.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;/*&#10;        Request style from client&#10;&#10;        &quot;REQUEST TYPE (router will call function according to req type)&#10;        PAYLOAD/BODY&quot;&#10;&#10;        for messaging&#10;        &quot;MSG&#10;         RECEIVER PHONE&#10;         name:message:timestamp&quot;&#10;&#10;         for login&#10;         &quot;LOGIN&#10;          PHONE&#10;          PASSWORD&quot;&#10;&#10;          for account creation&#10;         &quot;CREATE&#10;          NAME&#10;          PHONE&#10;          PASSWORD&#10;          URL&#10;          &quot;&#10;&#10;          for searching accounts&#10;         &quot;SEARCH&#10;          NAME&#10;          &quot;&#10;          for getting all chat update&#10;         &quot;CHAT_UPDATE&#10;          PHONE&#10;          &quot;&#10;&#10;&#10;        server will response the client with a status code and then payload&#10;&#10;        &quot;STATUS_CODE&#10;         PAYLOAD&quot;&#10;&#10;         status codes&#10;         200 -&gt; ok&#10;         401 -&gt; unauthorized&#10;         404 -&gt; not found&#10;         500 -&gt; internal server error&#10;&#10;&#10;&#10;&#10;*/&#10;&#10;&#10;public class ClientHandler {&#10;    private Socket socket;&#10;    private ObjectInputStream request; // request will receive client data&#10;    private ObjectOutputStream response; // response will send data to client&#10;    private HashMap&lt;String, Socket&gt; clientMap; // for finding receiver socket with phone&#10;    private Response clientResponse;&#10;&#10;&#10;    // Helper method to send responses&#10;    private void sendResponse(String body, int statusCode) {&#10;        try {&#10;            Response serverResponse = new Response(&quot;server&quot;, body, statusCode, clientResponse.getRequestId());&#10;            response.writeObject(serverResponse);&#10;            response.flush();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public ClientHandler(Socket socket, HashMap&lt;String, Socket&gt; clientMap) {&#10;        this.socket = socket;&#10;        this.clientMap = clientMap;&#10;&#10;        // setting up streams for send and receive&#10;        try {&#10;            this.response = new ObjectOutputStream(socket.getOutputStream());&#10;            this.request = new ObjectInputStream(socket.getInputStream());&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;Stream Error !&quot;);&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void router() {&#10;        try {&#10;            while (true) {&#10;                // Read Response object from client&#10;                clientResponse = (Response) request.readObject();&#10;                System.out.println(&quot;Received request: &quot; + clientResponse.getRequestId());&#10;&#10;                if (clientResponse != null) {&#10;&#10;                    switch (clientResponse.getPath()) {&#10;                        case MSG:&#10;                            messageSend();&#10;                            break;&#10;                        case LOGIN:&#10;                            login();&#10;                            break;&#10;                        case CREATE_ACCOUNT:&#10;                            createUser();&#10;                            break;&#10;                        case SEARCH:&#10;                            searchUser();&#10;                            break;&#10;                        case BLOCK:&#10;                            block();&#10;                            break;&#10;                        case UNBLOCK:&#10;                            unBlock();&#10;                            break;&#10;                        case CHAT:&#10;                            chatFetch();&#10;                            break;&#10;&#10;                        case SINGLE_SEARCH:&#10;                            singleSearchUser();&#10;                            break;&#10;                    }&#10;                } else {&#10;                    System.out.println(&quot;The request is null&quot;);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;IO Error!&quot;);&#10;            e.printStackTrace();&#10;        } catch (ClassNotFoundException e) {&#10;            System.out.println(&quot;Class not found!&quot;);&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private void singleSearchUser() {&#10;&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Optional&lt;User&gt; mUser = User.find(body.receiverPhone);&#10;            System.out.println(&quot;Searching user: &quot; + body.receiverPhone);&#10;            if (!mUser.isPresent()) {&#10;                System.out.println(&quot;User not found: &quot;);&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                return;&#10;            }&#10;            User user = mUser.get();&#10;&#10;            System.out.println(user);&#10;&#10;            response.writeObject(new Response(&quot;server&quot;,user,200,clientResponse.getRequestId()));&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;&#10;    }&#10;&#10;    private void searchUser() {&#10;&#10;&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;            List&lt;User&gt; foundUsers = new ArrayList&lt;&gt;();&#10;            // using regular expression to find names&#10;            String regex = &quot;.*&quot; + Pattern.quote(body.recieverName) + &quot;.*&quot;;&#10;            Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);&#10;&#10;            for (User u : User.getAllUsers()) {&#10;                Matcher matcher = pattern.matcher(u.getName());&#10;                // if name matched and its not the sender&#10;                if (matcher.matches() &amp;&amp; !u.getPhone().equals(clientResponse.getSender())) {&#10;&#10;                    if(!u.isBlocked(body.phone))&#10;                    {&#10;                        System.out.println(u.getName());&#10;                        foundUsers.add(u);&#10;                    }&#10;&#10;&#10;&#10;&#10;                }&#10;            }&#10;&#10;            response.writeObject(new Response(&quot;server&quot;,foundUsers,200,clientResponse.getRequestId()));&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;&#10;    }&#10;&#10;    private void messageSend() {&#10;        try {&#10;&#10;            System.out.println(&quot;Message send request received: &quot; + clientResponse.getRequestId());&#10;            Message msg = (Message) clientResponse.getBody();&#10;&#10;            // checking if user is blocked or not&#10;&#10;            Optional&lt;User&gt; mUser = User.find(msg.getReceiver());&#10;            if (mUser.isPresent()) {&#10;                User user = mUser.get();&#10;                if (user.isBlocked(msg.getSender())) {&#10;                    // receiver blocked user , nothing to send or save&#10;                    response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                    return;&#10;                }&#10;            }&#10;            // if its the starting of the chat&#10;            Chat chat=null;&#10;            if(msg.isFirstMsg())&#10;            {&#10;                System.out.println(&quot;first message&quot;);&#10;                // Ensure sender/receiver order is correct&#10;                chat= Chat.createChat(msg.getSender(),msg.getReceiver());&#10;                User.find(msg.getReceiver()).get().getChatList().add(chat.getChatId());&#10;                User.find(msg.getSender()).get().getChatList().add(chat.getChatId());&#10;                User.saveAllToFile();&#10;&#10;                response.writeObject(new Response(&quot;server&quot;, chat, 200, clientResponse.getRequestId()));&#10;                msg.setChatId(chat.getChatId());&#10;            }&#10;&#10;            Socket receiverSocket = clientMap.get(msg.getReceiver());&#10;            ObjectOutputStream receiverStream = null;&#10;            if (receiverSocket != null) {&#10;                // Use a static map to cache ObjectOutputStreams per socket&#10;                receiverStream = getCachedOutputStream(receiverSocket);&#10;            }&#10;&#10;            if(!msg.isFirstMsg())&#10;            {&#10;                System.out.println(&quot;not first message&quot;);&#10;                chat = Chat.findChat(msg.getChatId());&#10;            }&#10;&#10;            chat.addMessage(msg);&#10;            response.writeObject(new Response(&quot;server&quot;, chat, 200, clientResponse.getRequestId()));&#10;&#10;&#10;            // receiver is online&#10;            if (receiverSocket != null &amp;&amp; receiverStream != null) {&#10;                if (msg.isFirstMsg()) {&#10;                    receiverStream.writeObject(chat);&#10;                } else {&#10;                    receiverStream.writeObject(msg);&#10;                }&#10;                receiverStream.flush();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error in messageSend: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // Cache ObjectOutputStream per socket to avoid stream corruption&#10;    private static final Map&lt;Socket, ObjectOutputStream&gt; outputStreamCache = new HashMap&lt;&gt;();&#10;    private ObjectOutputStream getCachedOutputStream(Socket socket) throws IOException {&#10;        if (!outputStreamCache.containsKey(socket)) {&#10;            outputStreamCache.put(socket, new ObjectOutputStream(socket.getOutputStream()));&#10;        }&#10;        return outputStreamCache.get(socket);&#10;    }&#10;&#10;    private void login() {&#10;        try {&#10;            Data body = (Data) clientResponse.getBody();&#10;            System.out.println(clientResponse.getRequestId());&#10;            System.out.println(&quot;hiii&quot;);&#10;            Optional&lt;User&gt; mUser = User.find(body.phone);&#10;&#10;            if (!mUser.isPresent()) {&#10;&#10;&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                return;&#10;&#10;            }&#10;            User user = mUser.get();&#10;&#10;            if (user.getPassword().equals(body.password)) {&#10;                response.writeObject(new Response(&quot;server&quot;,user,200,clientResponse.getRequestId()));&#10;                clientMap.put(user.getPhone(), socket);&#10;            } else {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;            }&#10;&#10;&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;&#10;&#10;    }&#10;&#10;    private void createUser() {&#10;&#10;        try {&#10;            User newUser = (User) clientResponse.getBody();&#10;            Optional&lt;User&gt; mUser = User.find(newUser.getPhone());&#10;            if (mUser.isPresent()) {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                return;&#10;            }&#10;            User.addUser(newUser);&#10;            response.writeObject(new Response(&quot;server&quot;,newUser,200,clientResponse.getRequestId()));&#10;            clientMap.put(newUser.getPhone(), socket);&#10;&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;&#10;    }&#10;&#10;    private void chatFetch() {&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Chat chat = Chat.findChat(body.chatId);&#10;&#10;            response.writeObject(new Response(&quot;server&quot;, chat, 200, clientResponse.getRequestId()));&#10;&#10;&#10;        } catch (Exception e) {&#10;            try {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;            } catch (IOException ex) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;    private void block() {&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Optional&lt;User&gt; mUser = User.find(body.phone);&#10;            if (mUser.isPresent()) {&#10;                User user = mUser.get();&#10;                user.block(body.receiverPhone);&#10;            }&#10;&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;    }&#10;    private void unBlock() {&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Optional&lt;User&gt; mUser = User.find(body.phone);&#10;            if (mUser.isPresent()) {&#10;                User user = mUser.get();&#10;                user.unblock(body.receiverPhone);&#10;            }&#10;&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.controller;&#10;&#10;import com.api.Data;&#10;import com.db.Chat;&#10;import com.db.Message;&#10;import com.db.User;&#10;import com.server.Response;&#10;&#10;import java.io.*;&#10;import java.net.Socket;&#10;import java.util.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;/*&#10;        Request style from client&#10;&#10;        &quot;REQUEST TYPE (router will call function according to req type)&#10;        PAYLOAD/BODY&quot;&#10;&#10;        for messaging&#10;        &quot;MSG&#10;         RECEIVER PHONE&#10;         name:message:timestamp&quot;&#10;&#10;         for login&#10;         &quot;LOGIN&#10;          PHONE&#10;          PASSWORD&quot;&#10;&#10;          for account creation&#10;         &quot;CREATE&#10;          NAME&#10;          PHONE&#10;          PASSWORD&#10;          URL&#10;          &quot;&#10;&#10;          for searching accounts&#10;         &quot;SEARCH&#10;          NAME&#10;          &quot;&#10;          for getting all chat update&#10;         &quot;CHAT_UPDATE&#10;          PHONE&#10;          &quot;&#10;&#10;&#10;        server will response the client with a status code and then payload&#10;&#10;        &quot;STATUS_CODE&#10;         PAYLOAD&quot;&#10;&#10;         status codes&#10;         200 -&gt; ok&#10;         401 -&gt; unauthorized&#10;         404 -&gt; not found&#10;         500 -&gt; internal server error&#10;&#10;&#10;&#10;&#10;*/&#10;&#10;&#10;public class ClientHandler {&#10;    private Socket socket;&#10;    private ObjectInputStream request; // request will receive client data&#10;    private ObjectOutputStream response; // response will send data to client&#10;    private HashMap&lt;String, Socket&gt; clientMap; // for finding receiver socket with phone&#10;    private Response clientResponse;&#10;&#10;&#10;    // Helper method to send responses&#10;    private void sendResponse(String body, int statusCode) {&#10;        try {&#10;            Response serverResponse = new Response(&quot;server&quot;, body, statusCode, clientResponse.getRequestId());&#10;            response.writeObject(serverResponse);&#10;            response.flush();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public ClientHandler(Socket socket, HashMap&lt;String, Socket&gt; clientMap) {&#10;        this.socket = socket;&#10;        this.clientMap = clientMap;&#10;&#10;        // setting up streams for send and receive&#10;        try {&#10;            this.response = new ObjectOutputStream(socket.getOutputStream());&#10;            this.request = new ObjectInputStream(socket.getInputStream());&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;Stream Error !&quot;);&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void router() {&#10;        try {&#10;            while (true) {&#10;                // Read Response object from client&#10;                clientResponse = (Response) request.readObject();&#10;                System.out.println(&quot;Received request: &quot; + clientResponse.getRequestId());&#10;&#10;                if (clientResponse != null) {&#10;&#10;                    switch (clientResponse.getPath()) {&#10;                        case MSG:&#10;                            messageSend();&#10;                            break;&#10;                        case LOGIN:&#10;                            login();&#10;                            break;&#10;                        case CREATE_ACCOUNT:&#10;                            createUser();&#10;                            break;&#10;                        case SEARCH:&#10;                            searchUser();&#10;                            break;&#10;                        case BLOCK:&#10;                            block();&#10;                            break;&#10;                        case UNBLOCK:&#10;                            unBlock();&#10;                            break;&#10;                        case CHAT:&#10;                            chatFetch();&#10;                            break;&#10;&#10;                        case SINGLE_SEARCH:&#10;                            singleSearchUser();&#10;                            break;&#10;                    }&#10;                } else {&#10;                    System.out.println(&quot;The request is null&quot;);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;IO Error!&quot;);&#10;            e.printStackTrace();&#10;        } catch (ClassNotFoundException e) {&#10;            System.out.println(&quot;Class not found!&quot;);&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private void singleSearchUser() {&#10;&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Optional&lt;User&gt; mUser = User.find(body.receiverPhone);&#10;            System.out.println(&quot;Searching user: &quot; + body.receiverPhone);&#10;            if (!mUser.isPresent()) {&#10;                System.out.println(&quot;User not found: &quot;);&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                return;&#10;            }&#10;            User user = mUser.get();&#10;&#10;            System.out.println(user);&#10;&#10;            response.writeObject(new Response(&quot;server&quot;,user,200,clientResponse.getRequestId()));&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;&#10;    }&#10;&#10;    private void searchUser() {&#10;&#10;&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;            List&lt;User&gt; foundUsers = new ArrayList&lt;&gt;();&#10;            // using regular expression to find names&#10;            String regex = &quot;.*&quot; + Pattern.quote(body.recieverName) + &quot;.*&quot;;&#10;            Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);&#10;&#10;            for (User u : User.getAllUsers()) {&#10;                Matcher matcher = pattern.matcher(u.getName());&#10;                // if name matched and its not the sender&#10;                if (matcher.matches() &amp;&amp; !u.getPhone().equals(clientResponse.getSender())) {&#10;&#10;                    if(!u.isBlocked(body.phone))&#10;                    {&#10;                        System.out.println(u.getName());&#10;                        foundUsers.add(u);&#10;                    }&#10;&#10;&#10;&#10;&#10;                }&#10;            }&#10;&#10;            response.writeObject(new Response(&quot;server&quot;,foundUsers,200,clientResponse.getRequestId()));&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;&#10;    }&#10;&#10;    private void messageSend() {&#10;        try {&#10;            System.out.println(&quot;Message send request received: &quot; + clientResponse.getRequestId());&#10;            Message msg = (Message) clientResponse.getBody();&#10;&#10;            // checking if user is blocked or not&#10;            Optional&lt;User&gt; mUser = User.find(msg.getReceiver());&#10;            if (mUser.isPresent()) {&#10;                User user = mUser.get();&#10;                if (user.isBlocked(msg.getSender())) {&#10;                    // receiver blocked user , nothing to send or save&#10;                    response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                    return;&#10;                }&#10;            }&#10;            // if its the starting of the chat&#10;            Chat chat = null;&#10;            if (msg.isFirstMsg()) {&#10;                System.out.println(&quot;first message&quot;);&#10;                chat = Chat.createChat(msg.getSender(), msg.getReceiver());&#10;                User.find(msg.getReceiver()).get().getChatList().add(chat.getChatId());&#10;                User.find(msg.getSender()).get().getChatList().add(chat.getChatId());&#10;                User.saveAllToFile();&#10;&#10;                response.writeObject(new Response(&quot;server&quot;, chat, 200, clientResponse.getRequestId()));&#10;                msg.setChatId(chat.getChatId());&#10;            }&#10;&#10;            Socket receiverSocket = clientMap.get(msg.getReceiver());&#10;            ObjectOutputStream receiverStream = null;&#10;            if (receiverSocket != null) {&#10;                receiverStream = getCachedOutputStream(receiverSocket);&#10;            }&#10;&#10;            if (!msg.isFirstMsg()) {&#10;                System.out.println(&quot;not first message&quot;);&#10;                chat = Chat.findChat(msg.getChatId());&#10;            }&#10;&#10;            chat.addMessage(msg);&#10;            response.writeObject(new Response(&quot;server&quot;, chat, 200, clientResponse.getRequestId()));&#10;&#10;            // receiver is online&#10;            if (receiverSocket != null &amp;&amp; receiverStream != null) {&#10;                try {&#10;                    if (msg.isFirstMsg()) {&#10;                        receiverStream.writeObject(chat);&#10;                    } else {&#10;                        receiverStream.writeObject(msg);&#10;                    }&#10;                    receiverStream.flush();&#10;                    System.out.println(&quot;Real-time message sent to receiver: &quot; + msg.getReceiver());&#10;                } catch (IOException e) {&#10;                    System.err.println(&quot;Failed to send real-time message to receiver: &quot; + msg.getReceiver());&#10;                    e.printStackTrace();&#10;                }&#10;            } else {&#10;                System.out.println(&quot;Receiver not online: &quot; + msg.getReceiver());&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error in messageSend: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // Cache ObjectOutputStream per socket to avoid stream corruption&#10;    private static final Map&lt;Socket, ObjectOutputStream&gt; outputStreamCache = new HashMap&lt;&gt;();&#10;    private ObjectOutputStream getCachedOutputStream(Socket socket) throws IOException {&#10;        if (!outputStreamCache.containsKey(socket)) {&#10;            outputStreamCache.put(socket, new ObjectOutputStream(socket.getOutputStream()));&#10;        }&#10;        return outputStreamCache.get(socket);&#10;    }&#10;&#10;    private void login() {&#10;        try {&#10;            Data body = (Data) clientResponse.getBody();&#10;            System.out.println(clientResponse.getRequestId());&#10;            System.out.println(&quot;hiii&quot;);&#10;            Optional&lt;User&gt; mUser = User.find(body.phone);&#10;&#10;            if (!mUser.isPresent()) {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                return;&#10;            }&#10;            User user = mUser.get();&#10;&#10;            if (user.getPassword().equals(body.password)) {&#10;                response.writeObject(new Response(&quot;server&quot;, user, 200, clientResponse.getRequestId()));&#10;                // Register user's socket for real-time messaging&#10;                clientMap.put(user.getPhone(), socket);&#10;            } else {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private void createUser() {&#10;        try {&#10;            User newUser = (User) clientResponse.getBody();&#10;            Optional&lt;User&gt; mUser = User.find(newUser.getPhone());&#10;            if (mUser.isPresent()) {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;                return;&#10;            }&#10;            User.addUser(newUser);&#10;            response.writeObject(new Response(&quot;server&quot;, newUser, 200, clientResponse.getRequestId()));&#10;            // Register new user's socket for real-time messaging&#10;            clientMap.put(newUser.getPhone(), socket);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private void chatFetch() {&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Chat chat = Chat.findChat(body.chatId);&#10;&#10;            response.writeObject(new Response(&quot;server&quot;, chat, 200, clientResponse.getRequestId()));&#10;&#10;&#10;        } catch (Exception e) {&#10;            try {&#10;                response.writeObject(new Response(500, clientResponse.getRequestId()));&#10;            } catch (IOException ex) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;    private void block() {&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Optional&lt;User&gt; mUser = User.find(body.phone);&#10;            if (mUser.isPresent()) {&#10;                User user = mUser.get();&#10;                user.block(body.receiverPhone);&#10;            }&#10;&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;    }&#10;    private void unBlock() {&#10;        try {&#10;&#10;            Data body = (Data) clientResponse.getBody();&#10;&#10;            Optional&lt;User&gt; mUser = User.find(body.phone);&#10;            if (mUser.isPresent()) {&#10;                User user = mUser.get();&#10;                user.unblock(body.receiverPhone);&#10;            }&#10;&#10;&#10;        } catch (Exception e) {&#10;&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>